<?php
/**
 * EcommerceApi
 * PHP version 7.3
 *
 * @category Class
 * @package  Apideck\Client
 * @author   Apideck
 * @link     https://apideck.com
 */

/**
 * Apideck
 *
 * The Apideck OpenAPI Spec: SDK Optimized
 *
 * The version of the OpenAPI document: 10.7.1
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Apideck\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Apideck\Client\ApiException;
use Apideck\Client\Configuration;
use Apideck\Client\HeaderSelector;
use Apideck\Client\ObjectSerializer;

/**
 * EcommerceApi Class Doc Comment
 *
 * @category Class
 * @package  Apideck\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class EcommerceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation customersAll
     *
     * List Customers
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\EcommerceCustomersFilter $filter Apply filters (optional)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Apideck\Client\Model\GetEcommerceCustomersResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse
     */
    public function customersAll($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $filter = null, $pass_through = null, $fields = null)
    {
        list($response) = $this->customersAllWithHttpInfo($raw, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $cursor, $limit, $filter, $pass_through, $fields);
        return $response;
    }

    /**
     * Operation customersAllWithHttpInfo
     *
     * List Customers
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\EcommerceCustomersFilter $filter Apply filters (optional)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Apideck\Client\Model\GetEcommerceCustomersResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function customersAllWithHttpInfo($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $filter = null, $pass_through = null, $fields = null)
    {
        $request = $this->customersAllRequest($raw, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $cursor, $limit, $filter, $pass_through, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Apideck\Client\Model\GetEcommerceCustomersResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\GetEcommerceCustomersResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Apideck\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Apideck\Client\Model\UnauthorizedResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnauthorizedResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\Apideck\Client\Model\PaymentRequiredResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\PaymentRequiredResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Apideck\Client\Model\NotFoundResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\NotFoundResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Apideck\Client\Model\UnprocessableResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnprocessableResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Apideck\Client\Model\UnexpectedErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnexpectedErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Apideck\Client\Model\GetEcommerceCustomersResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\GetEcommerceCustomersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\PaymentRequiredResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnprocessableResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnexpectedErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customersAllAsync
     *
     * List Customers
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\EcommerceCustomersFilter $filter Apply filters (optional)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersAllAsync($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $filter = null, $pass_through = null, $fields = null)
    {
        return $this->customersAllAsyncWithHttpInfo($raw, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $cursor, $limit, $filter, $pass_through, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersAllAsyncWithHttpInfo
     *
     * List Customers
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\EcommerceCustomersFilter $filter Apply filters (optional)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersAllAsyncWithHttpInfo($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $filter = null, $pass_through = null, $fields = null)
    {
        $returnType = '\Apideck\Client\Model\GetEcommerceCustomersResponse';
        $request = $this->customersAllRequest($raw, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $cursor, $limit, $filter, $pass_through, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersAll'
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\EcommerceCustomersFilter $filter Apply filters (optional)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customersAllRequest($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $filter = null, $pass_through = null, $fields = null)
    {
        if ($limit !== null && $limit > 200) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling EcommerceApi.customersAll, must be smaller than or equal to 200.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling EcommerceApi.customersAll, must be bigger than or equal to 1.');
        }


        $resourcePath = '/ecommerce/customers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params

        if ('raw' === 'raw') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw ? 'true' : 'false';
            }
        }


        if ($raw !== null && 'sort' === 'raw') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($raw !== null && 'filter' === 'raw') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($raw !== null && !('raw' === 'raw' || 'raw' === 'sort' || 'raw' === 'filter')) {
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw;
            }
        }
        // query params

        if ('raw' === 'cursor') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($cursor)) {
                foreach($cursor as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['cursor'] = $cursor ? 'true' : 'false';
            }
        }


        if ($cursor !== null && 'sort' === 'cursor') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($cursor !== null && 'filter' === 'cursor') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($cursor !== null && !('cursor' === 'raw' || 'cursor' === 'sort' || 'cursor' === 'filter')) {
            if('form' === 'form' && is_array($cursor)) {
                foreach($cursor as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['cursor'] = $cursor;
            }
        }
        // query params

        if ('raw' === 'limit') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit ? 'true' : 'false';
            }
        }


        if ($limit !== null && 'sort' === 'limit') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($limit !== null && 'filter' === 'limit') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($limit !== null && !('limit' === 'raw' || 'limit' === 'sort' || 'limit' === 'filter')) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params

        if ('raw' === 'filter') {
            // Support for raw as true/false parameter
            if('form' === 'deepObject' && is_array($filter)) {
                foreach($filter as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filter'] = $filter ? 'true' : 'false';
            }
        }


        if ($filter !== null && 'sort' === 'filter') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($filter !== null && 'filter' === 'filter') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($filter !== null && !('filter' === 'raw' || 'filter' === 'sort' || 'filter' === 'filter')) {
            if('form' === 'deepObject' && is_array($filter)) {
                foreach($filter as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filter'] = $filter;
            }
        }
        // query params

        if ('raw' === 'pass_through') {
            // Support for raw as true/false parameter
            if('form' === 'deepObject' && is_array($pass_through)) {
                foreach($pass_through as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pass_through'] = $pass_through ? 'true' : 'false';
            }
        }


        if ($pass_through !== null && 'sort' === 'pass_through') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($pass_through !== null && 'filter' === 'pass_through') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($pass_through !== null && !('pass_through' === 'raw' || 'pass_through' === 'sort' || 'pass_through' === 'filter')) {
            if('form' === 'deepObject' && is_array($pass_through)) {
                foreach($pass_through as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pass_through'] = $pass_through;
            }
        }
        // query params

        if ('raw' === 'fields') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields ? 'true' : 'false';
            }
        }


        if ($fields !== null && 'sort' === 'fields') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($fields !== null && 'filter' === 'fields') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($fields !== null && !('fields' === 'raw' || 'fields' === 'sort' || 'fields' === 'filter')) {
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields;
            }
        }

        // header params
        if ($x_apideck_consumer_id !== null) {
            $headerParams['x-apideck-consumer-id'] = ObjectSerializer::toHeaderValue($x_apideck_consumer_id);
        }
        // header params
        if ($x_apideck_app_id !== null) {
            $headerParams['x-apideck-app-id'] = ObjectSerializer::toHeaderValue($x_apideck_app_id);
        }
        // header params
        if ($x_apideck_service_id !== null) {
            $headerParams['x-apideck-service-id'] = ObjectSerializer::toHeaderValue($x_apideck_service_id);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = $this->config->getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customersOne
     *
     * Get Customer
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Apideck\Client\Model\GetEcommerceCustomerResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse
     */
    public function customersOne($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        list($response) = $this->customersOneWithHttpInfo($id, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields);
        return $response;
    }

    /**
     * Operation customersOneWithHttpInfo
     *
     * Get Customer
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Apideck\Client\Model\GetEcommerceCustomerResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function customersOneWithHttpInfo($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        $request = $this->customersOneRequest($id, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Apideck\Client\Model\GetEcommerceCustomerResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\GetEcommerceCustomerResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Apideck\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Apideck\Client\Model\UnauthorizedResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnauthorizedResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\Apideck\Client\Model\PaymentRequiredResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\PaymentRequiredResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Apideck\Client\Model\NotFoundResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\NotFoundResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Apideck\Client\Model\UnprocessableResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnprocessableResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Apideck\Client\Model\UnexpectedErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnexpectedErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Apideck\Client\Model\GetEcommerceCustomerResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\GetEcommerceCustomerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\PaymentRequiredResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnprocessableResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnexpectedErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customersOneAsync
     *
     * Get Customer
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersOneAsync($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        return $this->customersOneAsyncWithHttpInfo($id, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customersOneAsyncWithHttpInfo
     *
     * Get Customer
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customersOneAsyncWithHttpInfo($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        $returnType = '\Apideck\Client\Model\GetEcommerceCustomerResponse';
        $request = $this->customersOneRequest($id, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customersOne'
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function customersOneRequest($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling customersOne'
            );
        }

        $resourcePath = '/ecommerce/customers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params

        if ('raw' === 'raw') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw ? 'true' : 'false';
            }
        }


        if ($raw !== null && 'sort' === 'raw') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($raw !== null && 'filter' === 'raw') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($raw !== null && !('raw' === 'raw' || 'raw' === 'sort' || 'raw' === 'filter')) {
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw;
            }
        }
        // query params

        if ('raw' === 'fields') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields ? 'true' : 'false';
            }
        }


        if ($fields !== null && 'sort' === 'fields') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($fields !== null && 'filter' === 'fields') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($fields !== null && !('fields' === 'raw' || 'fields' === 'sort' || 'fields' === 'filter')) {
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields;
            }
        }

        // header params
        if ($x_apideck_consumer_id !== null) {
            $headerParams['x-apideck-consumer-id'] = ObjectSerializer::toHeaderValue($x_apideck_consumer_id);
        }
        // header params
        if ($x_apideck_app_id !== null) {
            $headerParams['x-apideck-app-id'] = ObjectSerializer::toHeaderValue($x_apideck_app_id);
        }
        // header params
        if ($x_apideck_service_id !== null) {
            $headerParams['x-apideck-service-id'] = ObjectSerializer::toHeaderValue($x_apideck_service_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = $this->config->getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersAll
     *
     * List Orders
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\EcommerceOrdersFilter $filter Apply filters (optional)
     * @param  \Apideck\Client\Model\OrdersSort $sort Apply sorting (optional)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Apideck\Client\Model\GetEcommerceOrdersResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse
     */
    public function ordersAll($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $filter = null, $sort = null, $pass_through = null, $fields = null)
    {
        list($response) = $this->ordersAllWithHttpInfo($raw, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $cursor, $limit, $filter, $sort, $pass_through, $fields);
        return $response;
    }

    /**
     * Operation ordersAllWithHttpInfo
     *
     * List Orders
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\EcommerceOrdersFilter $filter Apply filters (optional)
     * @param  \Apideck\Client\Model\OrdersSort $sort Apply sorting (optional)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Apideck\Client\Model\GetEcommerceOrdersResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersAllWithHttpInfo($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $filter = null, $sort = null, $pass_through = null, $fields = null)
    {
        $request = $this->ordersAllRequest($raw, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $cursor, $limit, $filter, $sort, $pass_through, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Apideck\Client\Model\GetEcommerceOrdersResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\GetEcommerceOrdersResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Apideck\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Apideck\Client\Model\UnauthorizedResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnauthorizedResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\Apideck\Client\Model\PaymentRequiredResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\PaymentRequiredResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Apideck\Client\Model\NotFoundResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\NotFoundResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Apideck\Client\Model\UnprocessableResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnprocessableResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Apideck\Client\Model\UnexpectedErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnexpectedErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Apideck\Client\Model\GetEcommerceOrdersResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\GetEcommerceOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\PaymentRequiredResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnprocessableResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnexpectedErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersAllAsync
     *
     * List Orders
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\EcommerceOrdersFilter $filter Apply filters (optional)
     * @param  \Apideck\Client\Model\OrdersSort $sort Apply sorting (optional)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersAllAsync($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $filter = null, $sort = null, $pass_through = null, $fields = null)
    {
        return $this->ordersAllAsyncWithHttpInfo($raw, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $cursor, $limit, $filter, $sort, $pass_through, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersAllAsyncWithHttpInfo
     *
     * List Orders
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\EcommerceOrdersFilter $filter Apply filters (optional)
     * @param  \Apideck\Client\Model\OrdersSort $sort Apply sorting (optional)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersAllAsyncWithHttpInfo($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $filter = null, $sort = null, $pass_through = null, $fields = null)
    {
        $returnType = '\Apideck\Client\Model\GetEcommerceOrdersResponse';
        $request = $this->ordersAllRequest($raw, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $cursor, $limit, $filter, $sort, $pass_through, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersAll'
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\EcommerceOrdersFilter $filter Apply filters (optional)
     * @param  \Apideck\Client\Model\OrdersSort $sort Apply sorting (optional)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ordersAllRequest($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $filter = null, $sort = null, $pass_through = null, $fields = null)
    {
        if ($limit !== null && $limit > 200) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling EcommerceApi.ordersAll, must be smaller than or equal to 200.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling EcommerceApi.ordersAll, must be bigger than or equal to 1.');
        }


        $resourcePath = '/ecommerce/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params

        if ('raw' === 'raw') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw ? 'true' : 'false';
            }
        }


        if ($raw !== null && 'sort' === 'raw') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($raw !== null && 'filter' === 'raw') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($raw !== null && !('raw' === 'raw' || 'raw' === 'sort' || 'raw' === 'filter')) {
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw;
            }
        }
        // query params

        if ('raw' === 'cursor') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($cursor)) {
                foreach($cursor as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['cursor'] = $cursor ? 'true' : 'false';
            }
        }


        if ($cursor !== null && 'sort' === 'cursor') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($cursor !== null && 'filter' === 'cursor') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($cursor !== null && !('cursor' === 'raw' || 'cursor' === 'sort' || 'cursor' === 'filter')) {
            if('form' === 'form' && is_array($cursor)) {
                foreach($cursor as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['cursor'] = $cursor;
            }
        }
        // query params

        if ('raw' === 'limit') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit ? 'true' : 'false';
            }
        }


        if ($limit !== null && 'sort' === 'limit') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($limit !== null && 'filter' === 'limit') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($limit !== null && !('limit' === 'raw' || 'limit' === 'sort' || 'limit' === 'filter')) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params

        if ('raw' === 'filter') {
            // Support for raw as true/false parameter
            if('form' === 'deepObject' && is_array($filter)) {
                foreach($filter as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filter'] = $filter ? 'true' : 'false';
            }
        }


        if ($filter !== null && 'sort' === 'filter') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($filter !== null && 'filter' === 'filter') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($filter !== null && !('filter' === 'raw' || 'filter' === 'sort' || 'filter' === 'filter')) {
            if('form' === 'deepObject' && is_array($filter)) {
                foreach($filter as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filter'] = $filter;
            }
        }
        // query params

        if ('raw' === 'sort') {
            // Support for raw as true/false parameter
            if('form' === 'deepObject' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort ? 'true' : 'false';
            }
        }


        if ($sort !== null && 'sort' === 'sort') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($sort !== null && 'filter' === 'sort') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($sort !== null && !('sort' === 'raw' || 'sort' === 'sort' || 'sort' === 'filter')) {
            if('form' === 'deepObject' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params

        if ('raw' === 'pass_through') {
            // Support for raw as true/false parameter
            if('form' === 'deepObject' && is_array($pass_through)) {
                foreach($pass_through as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pass_through'] = $pass_through ? 'true' : 'false';
            }
        }


        if ($pass_through !== null && 'sort' === 'pass_through') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($pass_through !== null && 'filter' === 'pass_through') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($pass_through !== null && !('pass_through' === 'raw' || 'pass_through' === 'sort' || 'pass_through' === 'filter')) {
            if('form' === 'deepObject' && is_array($pass_through)) {
                foreach($pass_through as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pass_through'] = $pass_through;
            }
        }
        // query params

        if ('raw' === 'fields') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields ? 'true' : 'false';
            }
        }


        if ($fields !== null && 'sort' === 'fields') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($fields !== null && 'filter' === 'fields') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($fields !== null && !('fields' === 'raw' || 'fields' === 'sort' || 'fields' === 'filter')) {
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields;
            }
        }

        // header params
        if ($x_apideck_consumer_id !== null) {
            $headerParams['x-apideck-consumer-id'] = ObjectSerializer::toHeaderValue($x_apideck_consumer_id);
        }
        // header params
        if ($x_apideck_app_id !== null) {
            $headerParams['x-apideck-app-id'] = ObjectSerializer::toHeaderValue($x_apideck_app_id);
        }
        // header params
        if ($x_apideck_service_id !== null) {
            $headerParams['x-apideck-service-id'] = ObjectSerializer::toHeaderValue($x_apideck_service_id);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = $this->config->getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ordersOne
     *
     * Get Order
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Apideck\Client\Model\GetEcommerceOrderResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse
     */
    public function ordersOne($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        list($response) = $this->ordersOneWithHttpInfo($id, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields);
        return $response;
    }

    /**
     * Operation ordersOneWithHttpInfo
     *
     * Get Order
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Apideck\Client\Model\GetEcommerceOrderResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function ordersOneWithHttpInfo($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        $request = $this->ordersOneRequest($id, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Apideck\Client\Model\GetEcommerceOrderResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\GetEcommerceOrderResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Apideck\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Apideck\Client\Model\UnauthorizedResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnauthorizedResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\Apideck\Client\Model\PaymentRequiredResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\PaymentRequiredResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Apideck\Client\Model\NotFoundResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\NotFoundResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Apideck\Client\Model\UnprocessableResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnprocessableResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Apideck\Client\Model\UnexpectedErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnexpectedErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Apideck\Client\Model\GetEcommerceOrderResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\GetEcommerceOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\PaymentRequiredResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnprocessableResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnexpectedErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation ordersOneAsync
     *
     * Get Order
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOneAsync($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        return $this->ordersOneAsyncWithHttpInfo($id, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ordersOneAsyncWithHttpInfo
     *
     * Get Order
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ordersOneAsyncWithHttpInfo($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        $returnType = '\Apideck\Client\Model\GetEcommerceOrderResponse';
        $request = $this->ordersOneRequest($id, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ordersOne'
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function ordersOneRequest($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling ordersOne'
            );
        }

        $resourcePath = '/ecommerce/orders/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params

        if ('raw' === 'raw') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw ? 'true' : 'false';
            }
        }


        if ($raw !== null && 'sort' === 'raw') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($raw !== null && 'filter' === 'raw') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($raw !== null && !('raw' === 'raw' || 'raw' === 'sort' || 'raw' === 'filter')) {
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw;
            }
        }
        // query params

        if ('raw' === 'fields') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields ? 'true' : 'false';
            }
        }


        if ($fields !== null && 'sort' === 'fields') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($fields !== null && 'filter' === 'fields') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($fields !== null && !('fields' === 'raw' || 'fields' === 'sort' || 'fields' === 'filter')) {
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields;
            }
        }

        // header params
        if ($x_apideck_consumer_id !== null) {
            $headerParams['x-apideck-consumer-id'] = ObjectSerializer::toHeaderValue($x_apideck_consumer_id);
        }
        // header params
        if ($x_apideck_app_id !== null) {
            $headerParams['x-apideck-app-id'] = ObjectSerializer::toHeaderValue($x_apideck_app_id);
        }
        // header params
        if ($x_apideck_service_id !== null) {
            $headerParams['x-apideck-service-id'] = ObjectSerializer::toHeaderValue($x_apideck_service_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = $this->config->getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsAll
     *
     * List Products
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Apideck\Client\Model\GetProductsResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse
     */
    public function productsAll($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $pass_through = null, $fields = null)
    {
        list($response) = $this->productsAllWithHttpInfo($raw, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $cursor, $limit, $pass_through, $fields);
        return $response;
    }

    /**
     * Operation productsAllWithHttpInfo
     *
     * List Products
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Apideck\Client\Model\GetProductsResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsAllWithHttpInfo($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $pass_through = null, $fields = null)
    {
        $request = $this->productsAllRequest($raw, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $cursor, $limit, $pass_through, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Apideck\Client\Model\GetProductsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\GetProductsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Apideck\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Apideck\Client\Model\UnauthorizedResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnauthorizedResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\Apideck\Client\Model\PaymentRequiredResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\PaymentRequiredResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Apideck\Client\Model\NotFoundResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\NotFoundResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Apideck\Client\Model\UnprocessableResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnprocessableResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Apideck\Client\Model\UnexpectedErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnexpectedErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Apideck\Client\Model\GetProductsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\GetProductsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\PaymentRequiredResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnprocessableResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnexpectedErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsAllAsync
     *
     * List Products
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAllAsync($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $pass_through = null, $fields = null)
    {
        return $this->productsAllAsyncWithHttpInfo($raw, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $cursor, $limit, $pass_through, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsAllAsyncWithHttpInfo
     *
     * List Products
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsAllAsyncWithHttpInfo($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $pass_through = null, $fields = null)
    {
        $returnType = '\Apideck\Client\Model\GetProductsResponse';
        $request = $this->productsAllRequest($raw, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $cursor, $limit, $pass_through, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsAll'
     *
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  string $cursor Cursor to start from. You can find cursors for next/previous pages in the meta.cursors property of the response. (optional)
     * @param  int $limit Number of results to return. Minimum 1, Maximum 200, Default 20 (optional, default to 20)
     * @param  \Apideck\Client\Model\PassThroughQuery $pass_through Optional unmapped key/values that will be passed through to downstream as query parameters. Ie: ?pass_through[search]&#x3D;leads becomes ?search&#x3D;leads (optional)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsAllRequest($raw = false, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $cursor = null, $limit = 20, $pass_through = null, $fields = null)
    {
        if ($limit !== null && $limit > 200) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling EcommerceApi.productsAll, must be smaller than or equal to 200.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling EcommerceApi.productsAll, must be bigger than or equal to 1.');
        }


        $resourcePath = '/ecommerce/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params

        if ('raw' === 'raw') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw ? 'true' : 'false';
            }
        }


        if ($raw !== null && 'sort' === 'raw') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($raw !== null && 'filter' === 'raw') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($raw !== null && !('raw' === 'raw' || 'raw' === 'sort' || 'raw' === 'filter')) {
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw;
            }
        }
        // query params

        if ('raw' === 'cursor') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($cursor)) {
                foreach($cursor as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['cursor'] = $cursor ? 'true' : 'false';
            }
        }


        if ($cursor !== null && 'sort' === 'cursor') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($cursor !== null && 'filter' === 'cursor') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($cursor !== null && !('cursor' === 'raw' || 'cursor' === 'sort' || 'cursor' === 'filter')) {
            if('form' === 'form' && is_array($cursor)) {
                foreach($cursor as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['cursor'] = $cursor;
            }
        }
        // query params

        if ('raw' === 'limit') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit ? 'true' : 'false';
            }
        }


        if ($limit !== null && 'sort' === 'limit') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($limit !== null && 'filter' === 'limit') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($limit !== null && !('limit' === 'raw' || 'limit' === 'sort' || 'limit' === 'filter')) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params

        if ('raw' === 'pass_through') {
            // Support for raw as true/false parameter
            if('form' === 'deepObject' && is_array($pass_through)) {
                foreach($pass_through as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pass_through'] = $pass_through ? 'true' : 'false';
            }
        }


        if ($pass_through !== null && 'sort' === 'pass_through') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($pass_through !== null && 'filter' === 'pass_through') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($pass_through !== null && !('pass_through' === 'raw' || 'pass_through' === 'sort' || 'pass_through' === 'filter')) {
            if('form' === 'deepObject' && is_array($pass_through)) {
                foreach($pass_through as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pass_through'] = $pass_through;
            }
        }
        // query params

        if ('raw' === 'fields') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields ? 'true' : 'false';
            }
        }


        if ($fields !== null && 'sort' === 'fields') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($fields !== null && 'filter' === 'fields') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($fields !== null && !('fields' === 'raw' || 'fields' === 'sort' || 'fields' === 'filter')) {
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields;
            }
        }

        // header params
        if ($x_apideck_consumer_id !== null) {
            $headerParams['x-apideck-consumer-id'] = ObjectSerializer::toHeaderValue($x_apideck_consumer_id);
        }
        // header params
        if ($x_apideck_app_id !== null) {
            $headerParams['x-apideck-app-id'] = ObjectSerializer::toHeaderValue($x_apideck_app_id);
        }
        // header params
        if ($x_apideck_service_id !== null) {
            $headerParams['x-apideck-service-id'] = ObjectSerializer::toHeaderValue($x_apideck_service_id);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = $this->config->getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsOne
     *
     * Get Product
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Apideck\Client\Model\GetProductResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse
     */
    public function productsOne($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        list($response) = $this->productsOneWithHttpInfo($id, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields);
        return $response;
    }

    /**
     * Operation productsOneWithHttpInfo
     *
     * Get Product
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Apideck\Client\Model\GetProductResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsOneWithHttpInfo($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        $request = $this->productsOneRequest($id, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Apideck\Client\Model\GetProductResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\GetProductResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Apideck\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Apideck\Client\Model\UnauthorizedResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnauthorizedResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\Apideck\Client\Model\PaymentRequiredResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\PaymentRequiredResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Apideck\Client\Model\NotFoundResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\NotFoundResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Apideck\Client\Model\UnprocessableResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnprocessableResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Apideck\Client\Model\UnexpectedErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnexpectedErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Apideck\Client\Model\GetProductResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\GetProductResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\PaymentRequiredResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnprocessableResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnexpectedErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsOneAsync
     *
     * Get Product
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsOneAsync($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        return $this->productsOneAsyncWithHttpInfo($id, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsOneAsyncWithHttpInfo
     *
     * Get Product
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsOneAsyncWithHttpInfo($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        $returnType = '\Apideck\Client\Model\GetProductResponse';
        $request = $this->productsOneRequest($id, $x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsOne'
     *
     * @param  string $id ID of the record you are acting upon. (required)
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsOneRequest($id, $x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsOne'
            );
        }

        $resourcePath = '/ecommerce/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params

        if ('raw' === 'raw') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw ? 'true' : 'false';
            }
        }


        if ($raw !== null && 'sort' === 'raw') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($raw !== null && 'filter' === 'raw') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($raw !== null && !('raw' === 'raw' || 'raw' === 'sort' || 'raw' === 'filter')) {
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw;
            }
        }
        // query params

        if ('raw' === 'fields') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields ? 'true' : 'false';
            }
        }


        if ($fields !== null && 'sort' === 'fields') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($fields !== null && 'filter' === 'fields') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($fields !== null && !('fields' === 'raw' || 'fields' === 'sort' || 'fields' === 'filter')) {
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields;
            }
        }

        // header params
        if ($x_apideck_consumer_id !== null) {
            $headerParams['x-apideck-consumer-id'] = ObjectSerializer::toHeaderValue($x_apideck_consumer_id);
        }
        // header params
        if ($x_apideck_app_id !== null) {
            $headerParams['x-apideck-app-id'] = ObjectSerializer::toHeaderValue($x_apideck_app_id);
        }
        // header params
        if ($x_apideck_service_id !== null) {
            $headerParams['x-apideck-service-id'] = ObjectSerializer::toHeaderValue($x_apideck_service_id);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = $this->config->getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storesOne
     *
     * Get Store
     *
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Apideck\Client\Model\GetStoreResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse
     */
    public function storesOne($x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        list($response) = $this->storesOneWithHttpInfo($x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields);
        return $response;
    }

    /**
     * Operation storesOneWithHttpInfo
     *
     * Get Store
     *
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \Apideck\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Apideck\Client\Model\GetStoreResponse|\Apideck\Client\Model\BadRequestResponse|\Apideck\Client\Model\UnauthorizedResponse|\Apideck\Client\Model\PaymentRequiredResponse|\Apideck\Client\Model\NotFoundResponse|\Apideck\Client\Model\UnprocessableResponse|\Apideck\Client\Model\UnexpectedErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function storesOneWithHttpInfo($x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        $request = $this->storesOneRequest($x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Apideck\Client\Model\GetStoreResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\GetStoreResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Apideck\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\Apideck\Client\Model\UnauthorizedResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnauthorizedResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\Apideck\Client\Model\PaymentRequiredResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\PaymentRequiredResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Apideck\Client\Model\NotFoundResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\NotFoundResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\Apideck\Client\Model\UnprocessableResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnprocessableResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\Apideck\Client\Model\UnexpectedErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Apideck\Client\Model\UnexpectedErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Apideck\Client\Model\GetStoreResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\GetStoreResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnauthorizedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\PaymentRequiredResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\NotFoundResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnprocessableResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Apideck\Client\Model\UnexpectedErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation storesOneAsync
     *
     * Get Store
     *
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storesOneAsync($x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        return $this->storesOneAsyncWithHttpInfo($x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storesOneAsyncWithHttpInfo
     *
     * Get Store
     *
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storesOneAsyncWithHttpInfo($x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {
        $returnType = '\Apideck\Client\Model\GetStoreResponse';
        $request = $this->storesOneRequest($x_apideck_consumer_id, $x_apideck_app_id, $x_apideck_service_id, $raw, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storesOne'
     *
     * @param  string $x_apideck_consumer_id ID of the consumer which you want to get or push data from (optional)
     * @param  string $x_apideck_app_id The ID of your Unify application (optional)
     * @param  string $x_apideck_service_id Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API. (optional)
     * @param  bool $raw Include raw response. Mostly used for debugging purposes (optional, default to false)
     * @param  string $fields The &#39;fields&#39; parameter allows API users to specify the fields they want to include in the API response. If this parameter is not present, the API will return all available fields. If this parameter is present, only the fields specified in the comma-separated string will be included in the response. Nested properties can also be requested by using a dot notation. &lt;br /&gt;&lt;br /&gt;Example: &#x60;fields&#x3D;name,email,addresses.city&#x60;&lt;br /&gt;&lt;br /&gt;In the example above, the response will only include the fields \&quot;name\&quot;, \&quot;email\&quot; and \&quot;addresses.city\&quot;. If any other fields are available, they will be excluded. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storesOneRequest($x_apideck_consumer_id = null, $x_apideck_app_id = null, $x_apideck_service_id = null, $raw = false, $fields = null)
    {

        $resourcePath = '/ecommerce/store';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params

        if ('raw' === 'raw') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw ? 'true' : 'false';
            }
        }


        if ($raw !== null && 'sort' === 'raw') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($raw !== null && 'filter' === 'raw') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($raw !== null && !('raw' === 'raw' || 'raw' === 'sort' || 'raw' === 'filter')) {
            if('form' === 'form' && is_array($raw)) {
                foreach($raw as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['raw'] = $raw;
            }
        }
        // query params

        if ('raw' === 'fields') {
            // Support for raw as true/false parameter
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields ? 'true' : 'false';
            }
        }


        if ($fields !== null && 'sort' === 'fields') {
          // Support for sort options
          $sort_data = $sort->jsonSerialize();
          foreach($sort_data as $key => $value) {
            $queryParams['sort['.$key.']'] = $value;
          }
        }

        if ($fields !== null && 'filter' === 'fields') {
          // Support for filter options
          $filter_data = $filter->jsonSerialize();
          foreach($filter_data as $key => $value) {
            $queryParams['filter['.$key.']'] = $value;
          }
        }
        if ($fields !== null && !('fields' === 'raw' || 'fields' === 'sort' || 'fields' === 'filter')) {
            if('form' === 'form' && is_array($fields)) {
                foreach($fields as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fields'] = $fields;
            }
        }

        // header params
        if ($x_apideck_consumer_id !== null) {
            $headerParams['x-apideck-consumer-id'] = ObjectSerializer::toHeaderValue($x_apideck_consumer_id);
        }
        // header params
        if ($x_apideck_app_id !== null) {
            $headerParams['x-apideck-app-id'] = ObjectSerializer::toHeaderValue($x_apideck_app_id);
        }
        // header params
        if ($x_apideck_service_id !== null) {
            $headerParams['x-apideck-service-id'] = ObjectSerializer::toHeaderValue($x_apideck_service_id);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = $this->config->getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
